<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
  A simple problem in Haskell, using monads (Part 2/3)
</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="icon" href="/sunicon.png">
    <!--https://commons.wikimedia.org/wiki/File:Sunicon.png-->
    
  </head>
  <body>
    
      

<nav>

  
    
      <a href="&#x2F;blog&#x2F;"
          class="nav-link nav-link-left
                  
                    nav-link-inactive
                  ">
        Articles
      </a>
    
      <a href="&#x2F;about&#x2F;"
          class="nav-link nav-link-left
                  
                    nav-link-inactive
                  ">
        About
      </a>
    
      <a href="&#x2F;it"
          class="nav-link nav-link-left
                  
                    nav-link-inactive
                  ">
        Italiano
      </a>
    
  

  


</nav>


    
    <div id="content">
      <h1>
  A simple problem in Haskell, using monads (Part 2/3)
</h1>
      


  
    
  


      

  
    <div class="date">2021-10-30</div>
  

  <p>This article is number 2 in a 3-part series. If you haven't read the first one,
you can find it [here]({% link en/_posts/2021-09-25-simple-haskell-monads.md %}).</p>
<p>In Part 1, we looked at a few examples of the
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:sequence"><code>sequence</code></a>
function to transform a list of monads into a monad of a list.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>&gt; sequence [Just 1, Just 2, Just 3]
</span><span>Just [1, 2, 3]
</span><span>
</span><span>&gt; sequence [Just 1, Nothing, Just 2]
</span><span>Nothing
</span><span>
</span><span>&gt; sequence [Just 1, Nothing, Just 2, Nothing]
</span><span>Nothing
</span></code></pre>
<p>A more impressive example is when you look at the <code>Either a</code> monad.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>&gt; sequence [Right 1, Right 2, Right 3]
</span><span>Right [1, 2, 3]
</span><span>
</span><span>&gt; sequence [Right 1, Left &#39;A&#39;, Right 2, Left &#39;B&#39;]
</span><span>Left &#39;A&#39;
</span></code></pre>
<p>The type of <code>sequence</code> in this case is <code>[Either a b] -&gt; Either a [b]</code>, so
the returned value, as we can see, is either <code>Left a</code> or <code>[b]</code>. On top of that,
the function returns the first occurrence of a <code>Left a</code> value, if it finds any.
Coming from an imperative background, this seemed a bit like magic to me at
first, so let's dive into the source code to see what happens behind the scenes.</p>
<p>The <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/src/Data-Traversable.html">source code</a>
for <code>sequence</code> is not very easy to follow, so let's walk through it here
(simplifying slightly). If you don't know what <strong>typeclasses</strong> are, you can read
up on them <a href="https://www.haskell.org/tutorial/classes.html">here</a>, or
<a href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102">here</a>.
Essentially, you can think of them as interfaces in object-oriented languages,
or traits in, e.g., Scala and Rust.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">class</span><span> (</span><span style="color:#ebcb8b;">Functor </span><span style="color:#bf616a;">t</span><span>, </span><span style="color:#ebcb8b;">Foldable </span><span style="color:#bf616a;">t</span><span>) =&gt; </span><span style="color:#ebcb8b;">Traversable </span><span style="color:#bf616a;">t </span><span style="color:#b48ead;">where
</span><span>    </span><span style="color:#8fa1b3;">traverse </span><span style="color:#b48ead;">:: Applicative </span><span style="color:#bf616a;">f </span><span style="color:#b48ead;">=&gt;</span><span> (</span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">f b</span><span>) </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">t a </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">f</span><span> (</span><span style="color:#bf616a;">t b</span><span>)
</span><span>    traverse f = sequenceA . fmap f
</span><span>
</span><span>    </span><span style="color:#8fa1b3;">sequenceA </span><span style="color:#b48ead;">:: Applicative </span><span style="color:#bf616a;">f </span><span style="color:#b48ead;">=&gt; </span><span style="color:#bf616a;">t</span><span> (</span><span style="color:#bf616a;">f a</span><span>) </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">f</span><span> (</span><span style="color:#bf616a;">t a</span><span>)
</span><span>    sequenceA = traverse id
</span><span>
</span><span>    </span><span style="color:#8fa1b3;">mapM </span><span style="color:#b48ead;">:: Monad </span><span style="color:#bf616a;">m </span><span style="color:#b48ead;">=&gt;</span><span> (</span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">m b</span><span>) </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">t a </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">m</span><span> (</span><span style="color:#bf616a;">t b</span><span>)
</span><span>    mapM = traverse
</span><span>
</span><span>    </span><span style="color:#8fa1b3;">sequence </span><span style="color:#b48ead;">:: Monad </span><span style="color:#bf616a;">m </span><span style="color:#b48ead;">=&gt; </span><span style="color:#bf616a;">t</span><span> (</span><span style="color:#bf616a;">m a</span><span>) </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">m</span><span> (</span><span style="color:#bf616a;">t a</span><span>)
</span><span>    sequence = sequenceA
</span><span>
</span><span>
</span><span style="color:#b48ead;">instance Traversable</span><span> [] </span><span style="color:#b48ead;">where
</span><span>    traverse f = </span><span style="color:#d08770;">List</span><span>.foldr cons_f (pure </span><span style="color:#d08770;">[]</span><span>)
</span><span>        </span><span style="color:#b48ead;">where</span><span> cons_f x ys = liftA2 </span><span style="color:#8fa1b3;">(:)</span><span> (f x) ys
</span></code></pre>
<p>So what's happening here? The code first defines the
<a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Prelude.html#t:Traversable"><code>Traversable</code></a>
typeclass with the following functions:</p>
<ul>
<li><code>traverse</code></li>
<li><code>sequenceA</code></li>
<li><code>mapM</code></li>
<li><code>sequence</code></li>
</ul>
<p>However, because these functions are defined in terms of each other, any
instance of <code>Traversable</code> only needs to implement either <code>traverse</code> or
<code>sequenceA</code> (which will override the default implementation).</p>
<p>The <code>Traversable []</code> instance only implements <code>traverse</code>. While the
implementation seems really small and simple, there is a lot going on, so let's
cover some basics first.</p>
<h2 id="the-functor-typeclass">The <code>Functor</code> typeclass</h2>
<p>The <a href="https://hackage.haskell.org/package/Cabal-3.6.2.0/docs/Distribution-Compat-Prelude-Internal.html#t:Functor"><code>Functor</code></a>
typeclass essentially provides the <code>fmap</code> function.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">fmap </span><span style="color:#b48ead;">::</span><span> (</span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">b</span><span>) </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">f a </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">f b
</span></code></pre>
<p><code>f a</code> and <code>f b</code> are two "wrapped" values -- let's look at an example in GHCi where <code>f = Either a</code>.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>&gt; fmap (*2) (Right 3)
</span><span>Right 6
</span><span>
</span><span>&gt; fmap (*2) (Left 3)
</span><span>Left 3
</span></code></pre>
<p>So <code>fmap</code> applies the first argument (a function) to the "content" of its second
argument. Why does it behave differently with <code>Right 3</code> and <code>Left 3</code> though? We
can find the answer in the
<a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/src/Data.Either.html#line-135"><code>Functor</code> implementation for <code>Either a</code></a>.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">instance Functor</span><span> (</span><span style="color:#b48ead;">Either </span><span style="color:#bf616a;">a</span><span>) </span><span style="color:#b48ead;">where
</span><span>    fmap _ (</span><span style="color:#d08770;">Left</span><span> x) = </span><span style="color:#d08770;">Left</span><span> x
</span><span>    fmap f (</span><span style="color:#d08770;">Right</span><span> y) = </span><span style="color:#d08770;">Right</span><span> (f y)
</span></code></pre>
<p>No matter what you apply to a <code>Left a</code> value, you will always get back the same
<code>Left a</code>. This makes sense, because <code>Left</code> is conventionally a constructor for
error types: it means something went wrong.</p>
<h2 id="the-applicative-typeclass">The <code>Applicative</code> typeclass</h2>
<p>The <a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Prelude.html#t:Applicative"><code>Applicative</code></a>
typeclass provides the <code>(&lt;*&gt;)</code>, <code>pure</code> and <code>liftA2</code> functions, as well as a few others
which we won't go into. Let's take a look at the
<a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/src/GHC.Base.html#Applicative">source code</a>.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Functor </span><span style="color:#bf616a;">f</span><span> =&gt; </span><span style="color:#ebcb8b;">Applicative </span><span style="color:#bf616a;">f </span><span style="color:#b48ead;">where
</span><span>    </span><span style="color:#8fa1b3;">pure </span><span style="color:#b48ead;">:: </span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">f a
</span><span>
</span><span>    </span><span style="color:#8fa1b3;">(&lt;*&gt;) </span><span>:: f (a -&gt; b) -&gt; f a -&gt; f b
</span><span>    </span><span style="color:#8fa1b3;">(&lt;*&gt;) </span><span>= liftA2 id
</span><span>
</span><span>    </span><span style="color:#8fa1b3;">liftA2 </span><span style="color:#b48ead;">::</span><span> (</span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">b </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">c</span><span>) </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">f a </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">f b </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">f c
</span><span>    liftA2 f x = </span><span style="color:#8fa1b3;">(&lt;*&gt;)</span><span> (fmap f x)
</span><span>
</span><span>    </span><span style="color:#65737e;">-- [...]
</span></code></pre>
<p>Again, because <code>(&lt;*&gt;)</code> and <code>liftA2</code> are defined in terms of each other,
instances of <code>Applicative</code> are only required to implement one of them (along
with <code>pure</code>, which is not implemented in the typeclass). Also recall that the
<code>id</code> function just returns whatever argument you give to it, so for example <code>id (Right 3)</code> will return <code>Right 3</code>.</p>
<p>Let's take a look at how <code>liftA2</code> and <code>(&lt;*&gt;)</code> work in GHCi.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>&gt; import Control.Applicative
</span><span>
</span><span>&gt; liftA2 (:) (Right 1) (Right [2, 3])
</span><span>Right [1, 2, 3]
</span><span>
</span><span>&gt; Right (*2) &lt;*&gt; Right 3
</span><span>Right 6
</span></code></pre>
<p>So <code>liftA2</code> takes a binary function (such as <code>(:)</code>) and applies it to the "contents" of its next
2 arguments. <code>(&lt;*&gt;)</code> instead is like <code>fmap</code>, but it takes a function that is
wrapped into some <code>Functor</code> type (<code>Either a</code> in this example).</p>
<p>Now consider this: what happens if we use <code>Left a</code> values in the examples above?</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>&gt; import Control.Applicative
</span><span>
</span><span>&gt; liftA2 (:) (Left 1) (Right [2, 3])
</span><span>Left 1
</span><span>
</span><span>&gt; liftA2 (:) (Right 1) (Left 2)
</span><span>Left 2
</span><span>
</span><span>&gt; Right (*2) &lt;*&gt; Left 3
</span><span>Left 3
</span></code></pre>
<p>Once again, <code>Left a</code> values are left unchanged, and we can see why this happens
by looking at
<a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/src/Data.Either.html#line-151">how <code>Either a</code> implements <code>Applicative</code></a>.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">instance Applicative</span><span> (</span><span style="color:#b48ead;">Either </span><span style="color:#bf616a;">e</span><span>) </span><span style="color:#b48ead;">where
</span><span>    pure          = </span><span style="color:#d08770;">Right
</span><span>    </span><span style="color:#d08770;">Left</span><span>  e &lt;*&gt; _ = </span><span style="color:#d08770;">Left</span><span> e
</span><span>    </span><span style="color:#d08770;">Right</span><span> f &lt;*&gt; r = fmap f r
</span></code></pre>
<p>If the first argument is <code>Left a</code>, the <code>(&lt;*&gt;)</code> function returns it unchanged. If
instead
the second one is <code>Left a</code>, then the <code>fmap</code> function is called, which also returns it unchanged.
One important thing to note is that, if both arguments are <code>Left a</code>, then the
<strong>first one</strong> will be returned. As we'll see later, this is what enables
<code>sequence</code> and <code>mapM</code> to return the first incorrect element, if any.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>&gt; liftA2 </span><span style="color:#8fa1b3;">(:)</span><span> (</span><span style="color:#d08770;">Left 3</span><span>) (</span><span style="color:#d08770;">Left 4</span><span>)
</span><span style="color:#d08770;">Left 3
</span></code></pre>
<h2 id="back-to-traversable">Back to <code>Traversable</code></h2>
<p>We saw at the beginning of the article that both <code>sequence</code> and <code>mapM</code> are
provided by the <code>Traversable</code> typeclass and are implemented in terms of the
<code>traverse</code> function.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">instance Traversable</span><span> [] </span><span style="color:#b48ead;">where
</span><span>    traverse f = </span><span style="color:#d08770;">List</span><span>.foldr cons_f (pure </span><span style="color:#d08770;">[]</span><span>)
</span><span>        </span><span style="color:#b48ead;">where</span><span> cons_f x ys = liftA2 </span><span style="color:#8fa1b3;">(:)</span><span> (f x) ys
</span></code></pre>
<p>Recall the type of <code>traverse</code> for a list:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">traverse </span><span style="color:#b48ead;">:: Applicative </span><span style="color:#bf616a;">f </span><span style="color:#b48ead;">=&gt;</span><span> (</span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">f b</span><span>) </span><span style="color:#b48ead;">-&gt;</span><span> [</span><span style="color:#bf616a;">a</span><span>] </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">f</span><span> [</span><span style="color:#bf616a;">b</span><span>]
</span></code></pre>
<p>Let's again take an example in which <code>f = Either e</code> (sorry for changing the
letter).</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">traverse </span><span style="color:#b48ead;">::</span><span> (</span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; Either </span><span style="color:#bf616a;">e b</span><span>) </span><span style="color:#b48ead;">-&gt;</span><span> [</span><span style="color:#bf616a;">a</span><span>] </span><span style="color:#b48ead;">-&gt; Either </span><span style="color:#bf616a;">e</span><span> [</span><span style="color:#bf616a;">b</span><span>]
</span></code></pre>
<p>So what happens in the implementation of <code>traverse</code>? Let's take a look at the
first line.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>traverse f = </span><span style="color:#d08770;">List</span><span>.foldr cons_f (pure </span><span style="color:#d08770;">[]</span><span>)
</span></code></pre>
<p><a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-List.html#v:foldr"><code>foldr</code></a>
is your typical reduce operation: it takes a function (<code>cons_f</code>), an
accumulator (<code>pure []</code>) and a list and accumulates all the elements.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>&gt; foldr </span><span style="color:#8fa1b3;">(+) </span><span style="color:#d08770;">0</span><span> [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>] </span><span style="color:#65737e;">-- 1 + 2 + 3 + 4
</span><span style="color:#d08770;">10
</span><span>
</span><span>&gt; foldr </span><span style="color:#8fa1b3;">(*) </span><span style="color:#d08770;">1 </span><span>$ take </span><span style="color:#d08770;">5</span><span> [</span><span style="color:#d08770;">1</span><span>..] </span><span style="color:#65737e;">-- 5! == 1 * 2 * 3 * 4 * 5
</span><span style="color:#d08770;">120
</span></code></pre>
<p>As for <code>pure []</code>, we saw in the implementation of <code>Applicative</code> for <code>Either e</code>
that it must return <code>Right []</code> (since <code>traverse</code> returns <code>Either e [b]</code> in this
example). Can you guess now what <code>cons_f</code> does? It has to perform a cons
operation (<code>(:)</code>) between the input list (<code>[a]</code>) and the contents of the
accumulator. Let's take a better look at the code</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>cons_f x ys = liftA2 </span><span style="color:#8fa1b3;">(:)</span><span> (f x) ys
</span></code></pre>
<p>By looking at the signature of <code>traverse</code>, we can derive the types of the
inputs, which are not specified in the <code>where</code> clause.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">f  </span><span style="color:#b48ead;">:: </span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; Either </span><span style="color:#bf616a;">e b
</span><span style="color:#8fa1b3;">x  </span><span style="color:#b48ead;">:: </span><span style="color:#bf616a;">a
</span><span style="color:#8fa1b3;">ys </span><span style="color:#b48ead;">:: Either </span><span style="color:#bf616a;">e</span><span> [</span><span style="color:#bf616a;">b</span><span>]
</span></code></pre>
<p>So <code>cons_f</code> takes an element of the input list (<code>x</code>), "lifts" it to <code>(f x) :: Either e b</code>, then appends it to the accumulator. The use of <code>liftA2</code> ensures, as
we saw previously, that if either <code>f x</code> or <code>ys</code> is of type <code>Left e</code>, then the
result will also be <code>Left e</code>. Let's take a look at an example of this.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">import </span><span>Data.Char(</span><span style="color:#8fa1b3;">digitToInt</span><span>)
</span><span>
</span><span style="color:#8fa1b3;">f </span><span style="color:#b48ead;">:: Char -&gt; Either Char Int
</span><span>f x
</span><span>    | x </span><span style="color:#8fa1b3;">`</span><span>elem</span><span style="color:#8fa1b3;">` </span><span>&quot;</span><span style="color:#a3be8c;">0123456789</span><span>&quot; = </span><span style="color:#d08770;">Right</span><span> (digitToInt x)
</span><span>    | otherwise             = </span><span style="color:#d08770;">Left</span><span> x
</span><span>
</span><span>
</span><span style="color:#8fa1b3;">cons_f </span><span style="color:#b48ead;">:: Char -&gt; Either Char</span><span> [</span><span style="color:#b48ead;">Int</span><span>] </span><span style="color:#b48ead;">-&gt; Either Char</span><span> [</span><span style="color:#b48ead;">Int</span><span>]
</span><span>cons_f x ys = liftA2 </span><span style="color:#8fa1b3;">(:)</span><span> (f x) ys
</span></code></pre>
<p><code>f</code> here takes a <code>Char</code> and transforms it into a <code>Right Int</code> if it's between 0 and 9,
otherwise it returns the unmodified input wrapped as a <code>Left Char</code>. If we
experiment with these functions in GHCi, we should expect the following
behavior.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>&gt; f &#39;</span><span style="color:#a3be8c;">3</span><span>&#39;
</span><span style="color:#d08770;">Right 3
</span><span>
</span><span>&gt; f &#39;</span><span style="color:#a3be8c;">x</span><span>&#39;
</span><span style="color:#d08770;">Left </span><span>&#39;</span><span style="color:#a3be8c;">x</span><span>&#39;
</span><span>
</span><span>&gt; cons_f &#39;</span><span style="color:#a3be8c;">3</span><span>&#39; (</span><span style="color:#d08770;">Right</span><span> [</span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">4</span><span>])
</span><span style="color:#d08770;">Right</span><span> [</span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">4</span><span>]
</span><span>
</span><span>&gt; cons_f &#39;</span><span style="color:#a3be8c;">x</span><span>&#39; (</span><span style="color:#d08770;">Right</span><span> [</span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">4</span><span>])
</span><span style="color:#d08770;">Left </span><span>&#39;</span><span style="color:#a3be8c;">x</span><span>&#39;
</span><span>
</span><span>&gt; cons_f &#39;</span><span style="color:#a3be8c;">3</span><span>&#39; (</span><span style="color:#d08770;">Left </span><span>&#39;</span><span style="color:#a3be8c;">x</span><span>&#39;)
</span><span style="color:#d08770;">Left </span><span>&#39;</span><span style="color:#a3be8c;">x</span><span>&#39;
</span><span>
</span><span>&gt; cons_f &#39;</span><span style="color:#a3be8c;">x</span><span>&#39; (</span><span style="color:#d08770;">Left </span><span>&#39;</span><span style="color:#a3be8c;">y</span><span>&#39;)
</span><span style="color:#d08770;">Left </span><span>&#39;</span><span style="color:#a3be8c;">x</span><span>&#39;
</span></code></pre>
<p>We can now start to see how the magic of <code>traverse</code> works: what happens if we
execute <code>traverse f "01x3y"</code>? (Recall that <code>String</code> is the same as <code>[Char]</code>).
I'm going to use a "mathematical" notation below to reduce the expression.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>traverse f &quot;</span><span style="color:#a3be8c;">01x3y</span><span>&quot; == foldr cons_f (</span><span style="color:#d08770;">Right []</span><span>) &quot;</span><span style="color:#a3be8c;">01x3y</span><span>&quot;
</span><span>                   == cons_f &#39;</span><span style="color:#a3be8c;">0</span><span>&#39; $ cons_f &#39;</span><span style="color:#a3be8c;">1</span><span>&#39; $ cons_f &#39;</span><span style="color:#a3be8c;">x</span><span>&#39; $ cons_f &#39;</span><span style="color:#a3be8c;">3</span><span>&#39; $ cons_f &#39;</span><span style="color:#a3be8c;">y</span><span>&#39; (</span><span style="color:#d08770;">Right []</span><span>)
</span><span>                   == cons_f &#39;</span><span style="color:#a3be8c;">0</span><span>&#39; $ cons_f &#39;</span><span style="color:#a3be8c;">1</span><span>&#39; $ cons_f &#39;</span><span style="color:#a3be8c;">x</span><span>&#39; $ cons_f &#39;</span><span style="color:#a3be8c;">3</span><span>&#39; </span><span style="color:#d08770;">Left </span><span>&#39;</span><span style="color:#a3be8c;">y</span><span>&#39;
</span><span>                   == cons_f &#39;</span><span style="color:#a3be8c;">0</span><span>&#39; $ cons_f &#39;</span><span style="color:#a3be8c;">1</span><span>&#39; $ cons_f &#39;</span><span style="color:#a3be8c;">x</span><span>&#39; </span><span style="color:#d08770;">Left </span><span>&#39;</span><span style="color:#a3be8c;">y</span><span>&#39;
</span><span>                   == cons_f &#39;</span><span style="color:#a3be8c;">0</span><span>&#39; $ cons_f &#39;</span><span style="color:#a3be8c;">1</span><span>&#39; $ </span><span style="color:#d08770;">Left </span><span>&#39;</span><span style="color:#a3be8c;">x</span><span>&#39;
</span><span>                   </span><span style="color:#65737e;">-- [...]
</span><span>                   == </span><span style="color:#d08770;">Left </span><span>&#39;</span><span style="color:#a3be8c;">x</span><span>&#39;
</span></code></pre>
<p>Now recall that <code>sequence = traverse id</code> and <code>mapM = traverse</code>. We can see now
why an expression like <code>sequence [Right 1, Left 'x', Left 'y']</code>
returns the <strong>first occurrence</strong> of a value of type <code>Left e</code> (<code>Left 'x'</code> in this
case): it's because the implementation of <code>&lt;*&gt;</code> for <code>Either e</code> always
returns the <strong>first <code>Left e</code> argument</strong>.</p>
<p>And that's all! The magic behind <code>sequence</code> and <code>mapM</code> is demystified. If we had
to summarize everything in a nutshell, we could simply say that it's all
determined by how the <code>Functor</code> and <code>Applicative</code> typeclasses are defined for <code>Either e</code>. Now
if you want to understand why <code>sequence [Just 3, Nothing, Just 4]</code> returns
<code>Nothing</code>, just go look at how those 2 typeclasses are implemented for
<a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Prelude.html#t:Maybe"><code>Maybe</code></a>.</p>
<p>In the final part of this article series (<a href="https://giorgiosav.github.io/blog/simple-haskell-monads-3/">Part 3</a>), we'll try to solve the "nucleotide" problem
described in <a href="https://giorgiosav.github.io/blog/simple-haskell-monads/">Part 1</a> with C++ and Rust.</p>


  


    </div>

    

  



  </body>
</html>
